---
title: "Tax Aware Asset Allocation"
author: "Rex Macey"
date: "May 2016"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Tax Aware Asset Allocation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

TaxAwareAA attempts to both allocate and locate assets in a mean-variant 
efficient manner. Its main functions include a function to create tax efficient,
efficient frontiers and to create a portfolio with a target standard deviation
that is efficient using resampling. These are efficient.frontier and
resample.target.risk.

To perform a tax aware asset allocation we need to have a set of assumptions 
about the assets (also called asset classes in this documentation).  These set
of assumptions are put in an object called a cma (capital market assumptions).
For clarity, we refer to the base, non-tax-adjusted set of capital market
assumptions as a cma.  If tax-adjusted we will use cma.ta. We also need to know
something about the investor.  We use an object called investor.  We can combine
a cmf and an investor into a tax-aware capital market assumption object, the
cma.ta.

We assume a set of returns and covariance matrix for a set of asset classes just
as we would in a non-tax-aware exercise. Additional information on the nature of
the asset classes is required so that we can calculate the impact of taxes.  For
example, we need the yield on each asset and the character of the income it
generates (ordinary income, tax-free income, qualified dividend).

We assume the investor has assets in three types of accounts: \describe{ 
\item{Taxable}{An account in which income and capital gains are subject to tax.
Example, a brokerage account for an individual.} \item{Deferred}{An account that
is taxed when the assets are withdrawn. Example, an IRA.} \item{Exempt}{An
account which is not subject to tax. Example, a Roth IRA} } We know amounts the
investor has in each type of account. Further, we know the rates at which
income, capital gains and qualified dividends are taxed.

To create a tax-aware cma, we triple the number of asset classes of the base 
cma. We would have each of the base asset classes in each of the three account
types and treat them separately. So if there were just bonds and stocks in the
base cma, in a tax-aware cma we have six asset classes.

The (after-tax) returns of the assets differ depending on their location. There
are arguments that the variance of the assets should also change, but this
version does not address that.  The argument for adjusting the risk is that in
the face of taxes, the government reduces the gain (or loss) thus reducing the
variability.  It is the author's opinion that covariance matrices, especially
generated on historical data, understate the risk which most investor's care
about which is downside risk in a crisis.  Historically based covariance
underestimates the higher volatility and correlations that often occur in a
crisis.  This is something to consider in future versions. The author has chosen
to address this in the future.  Since the user specifies tne covariance matrix,
the user may supply one that considers the impact of taxes.

This tax-aware optimization is similar to a non-tax aware.  We use 3x the number
of assets (N). The first N assets are those in the taxable account. The second N
are in the deferred. The last N are in the exempt account.  We add constraints
so the the weights in each match the proportions of the assets by account type. 
The user may specify constraints by base asset class.  For example, if the first
asset clas has a maximum weight of 25%, then this model introduces the
constraint that the sum of the weights of class [1] + class [N+1] + class [2N+1]
<= 0.25

The results is a set of weights across the 3N asset classes.

## Create an investor
Load the TaxAwareAA package and create an investor.  This investor has $1 million in a taxable account, $500,000 in a tax-deferred account, and $200,000 in a tax-exempt account.  The time horizon is 10 years. We supply the tax rates.  After initializing the investor we print the object to show that the package internally combines federal, state and surcharge rates so the rate is the federal rate plus the state rate plus the surcharge multiplied by (1-state rate) to account for the deductibility of state income taxes.  
```{r}
require(TaxAwareAA)
investor<-investor.create(value.taxable=1000000,
                          value.deferred=500000,
                          value.exempt=200000,
                          horizon=10,
                          taxrate.state=0.06,
                          taxrate.ordinc = 0.33,
                          taxrate.LTCG = 0.15,
                          taxrate.STCG=0.33,
                          taxrate.qualdiv = 0.15,
                          taxrate.surcharge = 0.038)
print(investor)
```

## Create a CMA (capital market assumptions) object
We start with a cma object pre-tax.  This object reflect our beliefs about asset classes for 
all investors, in other words how markets will perform.  This view is combined with the investor object which contains tax rates for a specific investor to create a tax aware cma (cma.ta).
 
### Sample data for asset classes including covariance and correlation matrices
Let's load a set of capital market assumptions and describe it. The following code loads some data for 17 asset classes.  cma is a list with 6 objects: **as_of_date** is the date associated with the forecasts.  **nclasses** is the number of asset classes.  **ac.data** is a table with details on each asset class. **corr** and **cov** are the correlation and covariance matrices respectively.  Only cov is required.  **nconstraints** are user specified constraints beyond the minimum and maximums per asset class.
```{r}

#cma<-readRDS("./vignettes/sample cma.rds") # loads a cma data
load(file="sample cma.rdata")
str(cma) # show structure
```

Within the ac.data table there are 13 required (Req.) columns and a few optional ones.

Column          | Req. | Description
--------------- | ---- | ------------------------------------------------------
ret             | No   | Arithmetic total return. In decimal.
yld             | Yes  | Yield 
growth          | Yes  | Growth rate of dividend  
valChg          | Yes  | Valuation change over horizon  
risk            | Yes  | Standard deviation  
IntOrd          | Yes  | Pct of income taxed at ordinary income rate
IntTE           | Yes  | Pct of income exempt from tax
DivQual         | Yes  | Pct of income taxed at qualified dividend rate
DivOrd          | Yes  | Pct of income taxed at ordinary dividend rate
Turnover        | Yes  | Pct of asset class sold during year
LTCG            | Yes  | Pct of capital gains taxed at long term rate
STCG            | Yes  | Pct of capital gains taxed at short term rate
Min             | Yes  | Minimum weight of class
Max             | Yes  | Maximum weight of class        
MinDomEqRel     | No   | Example of a user-defined constraint
MinQualFI       | No   | Example of a user-defined constraint

While before tax total return (**ret**) may seem important, to calculate after-tax return we need to understand the components of that return. That's why **yld**, **growth** and **valChg** are required.  With those we do not need the total return which is the sum of these components.  Note that the return and risk information is supplied in decimal, not percent.

Optional user-defined constraints are sets of coefficients (**MinDomEqRel** and **MinQualFI**).  When multiplied by the weights of the portfolios and summed, the sum must be non-negative for the constraint to be satisfied.  In this example, MinDomEqRel (the name is user supplied) requires that US stocks be at least 40% of the total stock market weight (ignoring REITs).  This will occur if $0.6*USLarge + 0.6*USSmall - 0.4*EAFEEquity - 0.4*EMEquity >= 0$.  For example, if USLarge were 20%, EAFEEquity were 30% and USCore were 50%, we would have $0.6*0.2 - 0.4*0.3 >= 0$ which simplifies to $0 >= 0$ which is true.  

## Create a tax-aware CMA (capital market assumptions) object
Here we combine the pretax cma information with the tax information from the investor to estimate after-tax returns for the asset classes if held in a taxable account, a tax-deferred account, and an exempt account.  We assume assets are withdrawn at the end of the horizon.  We ignore contributions and withdrawals (that's for a subsequent version).

Trivially,  after-tax returns in an exempt account which will match pre-tax numbers.

The after-tax returns in a deferred account are pretty simple.  An investment will grow to $(1+pre_tax_geometric_return)^horizon$ and that value will be subject to tax.  After tax the investor will have this amount less what was paid in federal and state taxes. We convert this dollar amount into a return by raising it to the (1/horizon) and subtracting 1.  Most investors think of the value of their deferred account before taxes.  If someone has $100 in an IRA, they think it's worth $100 which ignores the deferred tax liability.  By maintaining the fiction that the account today is worth $100, we understate the after-tax return by dividing an after-tax terminal value with a before-tax starting value.  Since the final dollar values are correct using these returns, the asset allocation is correct which is our goal.   

The after-tax return calculation in the taxable account is tedious but not complicated. Each year we calculate the income that would be received.  The income on an investment (as opposed to what may be received by an investor) grows by a growth rate.  The income is taxed based on its character (ordinary, qualified, etc) and the investor's tax rate.  Likewise there is capital gains depending on the growth and the turnover.  We assume the initial basis equals the initial value (a restriction that could be altered in future version).  The basis is updated each period according to sales and purchases.  Looping through all the periods of the horizon we arrive at a final income. This income along with the valuation change determines the final value of the asset.  This value is adjusted for a final sale assuming any gain (loss) is long-term.

Below are the before- and after-tax returns.  
```{r, results='asis'}
at.returns<-ATReturn.calc(cma,investor)
returns.df<-round(100*as.data.frame(at.returns),2)
returns.df<-cbind(round(100*cma$ac.data$ret,2),returns.df)
colnames(returns.df)<-c("Before Tax","AT Taxable","AT Deferred","AT Exempt")
#returns.df
knitr::kable(returns.df)
```

It is not necessary to call the ATReturn.calc directly as the function is called from cma.ta.create as shown below. And with the tax-aware cma we can build the efficient frontier.
```{r}
cma.ta<-cma.ta.create(cma,investor)
eff<-efficient.frontier(cma.ta)
```
```{r, fig.show='hold'}
plot(eff[,"Risk"],eff[,"Return"],main="Efficient Frontier",col="blue",xlab="Std. Dev.",ylab="Return")
```

```{r, echo=FALSE, results='asis'}
knitr::kable(round(100*eff,1))
```

## Asset Class Weights along the Frontier
First, let's just look at the weightings of the asset classes along the frontier across all accounts. Then let's see the weights by account type.
```{r, fig.show='hold'}
# across all accounts
w.ac<-round(100*(eff[,3:(cma.ta$base.nclasses+2)]+eff[,(cma.ta$base.nclasses+3):(2*cma.ta$base.nclasses+2)]+
                                     eff[,(2*cma.ta$base.nclasses+3):(3*cma.ta$base.nclasses+2)]),1)
colnames(w.ac)<-cma.ta$base.classes
EffPt17<-w.ac[17,] # for later
idx<- colSums(w.ac)!=0
w.ac<-w.ac[,idx]
barplot(t(w.ac),main="Asset Weights by Frontier Point - All Accounts",legend=colnames(w.ac),col=rainbow(n=ncol(w.ac)))
# taxable
w.ac<-round(100*(eff[,3:(cma.ta$base.nclasses+2)]),1)
colnames(w.ac)<-cma.ta$base.classes
idx<- colSums(w.ac)!=0
w.ac<-w.ac[,idx]
barplot(t(w.ac),main="Asset Weights by Frontier Point - Taxable",legend=colnames(w.ac),col=rainbow(n=ncol(w.ac)))
# deferred
w.ac<-round(100*(eff[,(cma.ta$base.nclasses+3):(2*cma.ta$base.nclasses+2)]),1)
colnames(w.ac)<-cma.ta$base.classes
idx<- colSums(w.ac)!=0
w.ac<-w.ac[,idx]
barplot(t(w.ac),main="Asset Weights by Frontier Point - Deferred",legend=colnames(w.ac),col=rainbow(n=ncol(w.ac)))
# exempt
w.ac<-round(100*(eff[,(2*cma.ta$base.nclasses+3):(3*cma.ta$base.nclasses+2)]),1)
colnames(w.ac)<-cma.ta$base.classes
idx<- colSums(w.ac)!=0
w.ac<-w.ac[,idx]
barplot(t(w.ac),main="Asset Weights by Frontier Point - Exempt",legend=colnames(w.ac),col=rainbow(n=ncol(w.ac)))
```
## Check of some of the constraints
In addition to checking the constraints, this shows how to manipulate the results.

### Account types
The proportions of the taxable, deferred and exempt accounts are: `r round(100*investor["taxed"]/(investor["taxed"]+investor["deferred"]+investor["exempt"]),2)`%,  
`r round(100*investor["deferred"]/(investor["taxed"]+investor["deferred"]+investor["exempt"]),2)`%, and
`r round(100*investor["exempt"]/(investor["taxed"]+investor["deferred"]+investor["exempt"]),2)`% respectively.
Below we see that the weights of the asset classes by account type matches.
```{r, results='asis'}
wts.by.acct<-round(100*data.frame(taxable=rowSums(eff[,3:(cma.ta$base.nclasses+2)]),
                        deferred=rowSums(eff[,(cma.ta$base.nclasses+3):(2*cma.ta$base.nclasses+2)]),
                        exempt=rowSums(eff[,(2*cma.ta$base.nclasses+3):(3*cma.ta$base.nclasses+2)])),2)

knitr::kable(wts.by.acct)
```

### Asset Class Min and Max
Let's compare the minimum and maximum weights of each asset class across the frontier with the constraints on the minimum and maximum.  
```{r}
w.ac<-round(100*(eff[,3:(cma.ta$base.nclasses+2)]+eff[,(cma.ta$base.nclasses+3):(2*cma.ta$base.nclasses+2)]+
                                     eff[,(2*cma.ta$base.nclasses+3):(3*cma.ta$base.nclasses+2)]),1)
colnames(w.ac)<-cma.ta$base.classes
box<-data.frame(Min=apply(w.ac,2,min),MinConstraint=100*cma.ta$boxMin,
                max=apply(w.ac,2,max),MaxConstraint=100*cma.ta$boxMax)

```

## Resampling
Included in this package is a function, resample.target.risk, that uses
resampling to find an efficient portfolio

This function finds a point on the efficient frontier with a specified target
standard deviation given a set of capital market assumptions. Resampling reduces
the impact of estimation error in the mean-variance process.  The process starts
with a set of assumptions. These are used to generate a set of random returns (a
sample). The return and covariance of this sample is computed and an efficient
point is created. This sampling is repeated.  The average allocations of the
samples is the result. This function allows the user to set a minimum threshold
for an asset class.  If an asset class's weight fails to meet the threshold, the
class's maximum weight is set to zero.  The resampling is repeated.  The
threshold is ignored for asset classes with minimum weights less than the
threshold (for example, if one sets a 1% minimum weight to cash and a threshold
of 2.5%, then a 1% cash weighting will be allowed.)

Below, we run the function setting a target risk to the same risk as the 17th 
point (an arbitrary choice) on the efficient frontier. The resampled portfolio
has greater diversification (more asset classes and more equal weights).  Its
return and risk are close to that from the  efficient frontier.
```{r}
resamp<-resample.target.risk(eff[17,2],cma.ta,n.samples=100,thresh=0.025)
w.ac<-round(100*(resamp$w[1:(cma.ta$base.nclasses)]+resamp$w[(cma.ta$base.nclasses+1):(2*cma.ta$base.nclasses)]+
                                     resamp$w[(2*cma.ta$base.nclasses+1):(3*cma.ta$base.nclasses)]),1)
names(w.ac)<-cma.ta$base.classes
w.ac
EffPt17
round(100*portret(resamp$w,cma.ta),2)
round(100*portret(eff[17,3:ncol(eff)],cma.ta),2)
round(100*portrisk(resamp$w,cma.ta),2)
round(100*portrisk(eff[17,3:ncol(eff)],cma.ta),2)
```
